cmake_minimum_required(VERSION 3.10)

# Applies a LARA file to the given target.
#
# Sources and includes of the target will be updated in order to point to the code generated by Clava.
#
# Parameter 1: The target that the LARA file will be applied to
# Parameter 2: A LARA file
# Parameter ARGS (one value): A string with the aspect arguments e.g., "inputFile:'data.json', execute:true, iterations:10"
# Parameter FLAGS (multi-value): A list of flags that will be passed to Clava during execution
# Parameter JAVA_FLAGS (multi-value): A list of flags that will be passed to the JVM during Clava execution
function(clava_weave ORIG_TARGET ASPECT)

    set(options)
    set(oneValueArgs ARGS)
    set(multiValueArgs FLAGS JAVA_FLAGS)
	
	# Setup Clava Node mode, if enabled
	if(DEFINED CLAVA_NODE AND CLAVA_NODE)
		get_filename_component(aspectAbsolutePath "${ASPECT}" ABSOLUTE)	
		get_filename_component(aspectParentDir "${aspectAbsolutePath}" DIRECTORY)
	
		# If package.json does not exist, create a default one
		if(NOT EXISTS "${aspectParentDir}/package.json")
			message(STATUS "Clava Node: Creating default package.json")
			set(jsonContents "{\n  \"type\": \"module\",\n  \"dependencies\": {\n    \"@specs-feup/clava\": \"^3.0.1\",\n    \"@specs-feup/lara\": \"^3.0.2\"\n  }\n}\n")			
			
			file(WRITE "${aspectParentDir}/package.json" "${jsonContents}")
		endif()		
	
		# If node_modules does not exist, call npm install
		if(NOT EXISTS "${aspectParentDir}/node_modules")
			message(STATUS "Clava Node: installing node packages")
			
			if(WIN32)
				set(NPM_CMD "npm.cmd")
			else()
				set(NPM_CMD "npm")			
			endif()

			execute_process(COMMAND ${NPM_CMD} install
				WORKING_DIRECTORY "${aspectParentDir}"
				OUTPUT_VARIABLE NPM_OUTPUT
				ERROR_VARIABLE NPM_ERROR
				RESULT_VARIABLE NPM_RESULT				
			)	
			
			
			if(${NPM_RESULT} STREQUAL "0")
				message(STATUS "${NPM_OUTPUT}")
			else()
				message(SEND_ERROR "npm install error: ${NPM_ERROR}")				
			endif()

		endif()
	endif()

    cmake_parse_arguments(PARSE_ARGV 2 CLAVA_WEAVE "${options}" "${oneValueArgs}" "${multiValueArgs}")

	#message(STATUS "ASPECT_ARGS: " ${CLAVA_WEAVE_ASPECT_ARGS})
	#message(STATUS "WEAVER_ARGS: " ${CLAVA_WEAVE_FLAGS})
	#message(STATUS "JAVA_ARGS: " ${CLAVA_WEAVE_JAVA_FLAGS})

	# Get standard automatically from the target and append to CLAVA_WEAVE_FLAGS
	clava_get_target_std(${ORIG_TARGET} CLAVA_STD_FLAG)
	set(CLAVA_WEAVE_FLAGS "${CLAVA_STD_FLAG} ${CLAVA_WEAVE_FLAGS}")

	# Create aspect arguments
	if(NOT ("${CLAVA_WEAVE_ARGS}" STREQUAL ""))
		set(ASPECT_ARGS_FLAG "-av")
		set(ASPECT_ARGS "\\\"${CLAVA_WEAVE_ARGS}\\\"")	
		#~ set(ASPECT_ARGS "{${CLAVA_WEAVE_ARGS}}")	
	else()
		set(ASPECT_ARGS_FLAG "")
		set(ASPECT_ARGS "")	
	endif()
	
	# Get build dir
	set(BUILD_DIR "${CMAKE_CURRENT_BINARY_DIR}")
	#message(STATUS "BUILD DIR: ${BUILD_DIR}") 

	# Woven dir name
	set(WOVEN_DIR_NAME "woven")
	
	# Working dir
	set(WORKING_DIR "${BUILD_DIR}/${ORIG_TARGET}_clava_weave")
	# Woven dir
	set(WOVEN_DIR "${WORKING_DIR}/${WOVEN_DIR_NAME}")

	file(MAKE_DIRECTORY "${WOVEN_DIR}")
	#message(STATUS "Woven dir: ${WOVEN_DIR}")
	

	# Get CMakeLists.txt dir
	clava_get_target_property(ORIG_CMAKE_DIR ${ORIG_TARGET} SOURCE_DIR)
	#message(STATUS "ORIG_CMAKE_DIR: ${ORIG_CMAKE_DIR}")


	
	# Set absolute path of aspect file relative to the source folder, in case path is relative
	if(NOT IS_ABSOLUTE ${ASPECT})
		set(ASPECT "${ORIG_CMAKE_DIR}/${ASPECT}")	
	endif()
	#message(STATUS "ASPECT: ${ASPECT}")

	
	# Get original source files
	clava_get_target_property(ORIG_SOURCES ${ORIG_TARGET} SOURCES)
	#message(STATUS "ORIG_SOURCES: ${ORIG_SOURCES}")
	
	# Initialize processed sources
	set(PROC_ORIG_SOURCES "")
	foreach(SOURCE ${ORIG_SOURCES})
		if(IS_ABSOLUTE ${SOURCE})
			set(PROC_SOURCE "${SOURCE}")	
		else()
			set(PROC_SOURCE "${ORIG_CMAKE_DIR}/${SOURCE}")			
		endif()
		
		LIST(APPEND PROC_ORIG_SOURCES "${PROC_SOURCE}")
	endforeach()	
	#message(STATUS "NEW PROC_ORIG_SOURCES: ${PROC_ORIG_SOURCES}")

	# Process original source file list
	# No longer needed, now Clava always uses ;
	#if(NOT "${CMAKE_HOST_SYSTEM}" MATCHES ".*Windows.*")
	#	string(REGEX REPLACE ";" ":" PROC_ORIG_SOURCES "${PROC_ORIG_SOURCES}")
	#endif()
	#message(STATUS "PROC_ORIG_SOURCES: ${PROC_ORIG_SOURCES}")

	# Get all include folders
	#message(STATUS "ORIG_TARGET: '${ORIG_TARGET}'")
	target_include_directories_recursive(${ORIG_TARGET} ORIG_INCLUDES)
	#message(STATUS "ORIG_INCLUDES: '${ORIG_INCLUDES}'")
	
#	# Get original include folders
#	clava_get_target_property(ORIG_INCLUDES ${ORIG_TARGET} INCLUDE_DIRECTORIES)
#	#message(STATUS "ORIG_INCLUDES: '${ORIG_INCLUDES}'")
#	
#	# If not found, set to empty list
#	if((${ORIG_INCLUDES} MATCHES "ORIG_INCLUDES-NOTFOUND"))
#		set(ORIG_INCLUDES "")
#	endif()
#
#	# Add includes of target link libraries
#	clava_get_target_property(ORIG_LINK_LIBRARIES ${ORIG_TARGET} LINK_LIBRARIES)
#	#message(STATUS "ORIG_LINK_LIBRARIES: ${ORIG_LINK_LIBRARIES}")		
#	
#	# If not found, set to empty list
#	if("${ORIG_LINK_LIBRARIES}" MATCHES "ORIG_LINK_LIBRARIES-NOTFOUND")
#		set(ORIG_LINK_LIBRARIES "")
#	endif()
#	
#	#message(STATUS "ORIG_LINK_LIBRARIES_LENGTH: ${ORIG_LINK_LIBRARIES_LENGTH}")
#
#	# Add include directories of linked targets
#	foreach(ORIG_LINK_LIB IN LISTS ORIG_LINK_LIBRARIES)
#		#message(STATUS "ORIG_LINK_LIB: ${ORIG_LINK_LIB}")
#		clava_get_target_property(ORIG_LINK_LIB_INC ${ORIG_LINK_LIB} INCLUDE_DIRECTORIES)
#		if("${ORIG_LINK_LIB_INC}" MATCHES "ORIG_LINK_LIB_INC-NOTFOUND")
#			set(ORIG_LINK_LIB_INC "")
#		endif()
#		list(APPEND ORIG_INCLUDES ORIG_LINK_LIB_INC)
#		#message(STATUS "ORIG_LINK_LIB_INC: ${ORIG_LINK_LIB_INC}")
#	endforeach(ORIG_LINK_LIB)	
	
	
	
	# Set include headers flag if include list is not empty
	list(LENGTH ORIG_INCLUDES ORIG_INLCUDES_LENGTH)
	if(ORIG_INLCUDES_LENGTH GREATER 0)
		set(INCLUDE_HEADERS_FLAG "-ih")
	else()
		set(INCLUDE_HEADERS_FLAG "")
	endif()
#	set(INCLUDE_HEADERS_FLAG "-ih")
#   if((${ORIG_INCLUDES} MATCHES "ORIG_INCLUDES-NOTFOUND") OR ("${ORIG_INCLUDES}" STREQUAL ""))
#        set(INCLUDE_HEADERS_FLAG "")
#        set(ORIG_INCLUDES "")
#    endif()
	#message(STATUS "ORIG_INCLUDES AFTER: '${ORIG_INCLUDES}'")

	
	# Process original includes list
	string(REGEX REPLACE "([^;]+)" "\\1" PROC_ORIG_INCLUDES "${ORIG_INCLUDES}")
	#message(STATUS "PROC_ORIG_INCLUDES: '${ORIG_INCLUDES}'")

	#if(NOT "${CMAKE_HOST_SYSTEM}" MATCHES ".*Windows.*")
	#	string(REGEX REPLACE ";" ":" PROC_ORIG_INCLUDES "${PROC_ORIG_INCLUDES}")
	#endif()
	#message(STATUS "INCLUDE HEADERS FLAG: ${INCLUDE_HEADERS_FLAG}")
	#message(STATUS "PROC_ORIG_INCLUDES AFTER REPLACE: ${PROC_ORIG_INCLUDES}")
	
	
	# Make the CMake configuration dependent on the LARA file and original sources
	set_property(DIRECTORY APPEND PROPERTY CMAKE_CONFIGURE_DEPENDS "${ASPECT};${ORIG_SOURCES}")
	
	# Mark Clava output directory as a target for 'make clean'
	set_property(DIRECTORY APPEND PROPERTY ADDITIONAL_MAKE_CLEAN_FILES "${WOVEN_DIR}")
		
	
	
	# Clean file with woven sources, if present
	file(REMOVE "${WOVEN_DIR}/clava_generated_files.txt")
	
	# Create CMakeLists.txt for weaving
	configure_file("${Clava_DIR}/clava/ClavaWeave.CMakeLists.txt" "${WORKING_DIR}/CMakeLists.txt")
	
	message(STATUS "Configuring weaving step")
	execute_process(COMMAND ${CMAKE_COMMAND} -G "${CMAKE_GENERATOR}"
                        "${WORKING_DIR}"
               WORKING_DIRECTORY "${WORKING_DIR}")
			   
	message(STATUS "Executing weaving step")
	execute_process(COMMAND ${CMAKE_COMMAND} --build . --target "${ORIG_TARGET}_weaving"
                WORKING_DIRECTORY "${WORKING_DIR}")
			   
	# Read new sources
	if(EXISTS "${WOVEN_DIR}/clava_generated_files.txt")
        file(READ "${WOVEN_DIR}/clava_generated_files.txt" CLAVA_WOVEN_SOURCES)
        string(STRIP "${CLAVA_WOVEN_SOURCES}" CLAVA_WOVEN_SOURCES)
        set_property(DIRECTORY APPEND PROPERTY CMAKE_CONFIGURE_DEPENDS "${CLAVA_WOVEN_SOURCES}")

		# Set new sources
		set_target_properties(${ORIG_TARGET}
			PROPERTIES SOURCES "${CLAVA_WOVEN_SOURCES}"
		)		
		
        #message(STATUS "CLAVA_WOVEN_SOURCES: ${CLAVA_WOVEN_SOURCES}")
	else()
		message(FATAL_ERROR "Could not find Clava file 'clava_generated_files.txt'")
	endif()
	
	# Read new includes
	if(EXISTS "${WOVEN_DIR}/clava_include_dirs.txt")
        file(READ "${WOVEN_DIR}/clava_include_dirs.txt" CLAVA_INCLUDE_DIRS)
        string(STRIP "${CLAVA_INCLUDE_DIRS}" CLAVA_INCLUDE_DIRS)

		# Set new include directories
		set_target_properties(${ORIG_TARGET}
			PROPERTIES INCLUDE_DIRECTORIES "${CLAVA_INCLUDE_DIRS}"
		)			
		
        #message(STATUS "CLAVA_INCLUDE_DIRS: ${CLAVA_INCLUDE_DIRS}")
	else()
		message(FATAL_ERROR "Could not find Clava file 'clava_include_dirs.txt'")
	endif()
	
	# Read new sub projects
	if(EXISTS "${WOVEN_DIR}/clava_sub_projects.txt")
        file(READ "${WOVEN_DIR}/clava_sub_projects.txt" CLAVA_SUB_PROJECTS)
        string(STRIP "${CLAVA_SUB_PROJECTS}" CLAVA_SUB_PROJECTS)

		# Set new sub projects
		foreach(SUB_PROJ IN LISTS CLAVA_SUB_PROJECTS)
			add_subdirectory(${SUB_PROJ} "${SUB_PROJ}/bin")
		endforeach(SUB_PROJ)
	else()
		message(FATAL_ERROR "Could not find Clava file 'clava_sub_projects.txt'")
	endif()

	# Read new sub libs
	if(EXISTS "${WOVEN_DIR}/clava_sub_libs.txt")
        file(READ "${WOVEN_DIR}/clava_sub_libs.txt" CLAVA_SUB_LIBS)
        string(STRIP "${CLAVA_SUB_LIBS}" CLAVA_SUB_LIBS)

		# Set new sub libs
		foreach(SUB_LIB IN LISTS CLAVA_SUB_LIBS)
			target_link_libraries(${ORIG_TARGET} ${SUB_LIB})
		endforeach(SUB_LIB)
	else()
		message(FATAL_ERROR "Could not find Clava file 'clava_sub_libs.txt'")
	endif()
endfunction(clava_weave)
