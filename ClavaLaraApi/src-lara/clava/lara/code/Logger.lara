import lara.code.LoggerBase;
import lara.util.IdGenerator;
import lara.util.PrintOnce;
import clava.Clava;



/**
 * If enabled, uses the SpecsLogger library for the C++ code.
 */
//Logger.prototype.useSpecsLogger = true;

Logger.prototype.ln = function(expr) {
    if(Clava.isCxx()) {
		return this._append_private("std::endl", this.Type.LITERAL);
	}
	
	return this._append_private("\\n", this.Type.NORMAL);
} 
 
/**
 * Adds code that prints the message built up to that point with the append() functions.
 *
 * TODO: Improve this comment, add JSDoc tags
 */
Logger.prototype.log = function($jp, insertBefore) {

	if($jp === undefined) {
		this._warn("Given join point is undefined");
		return;
	}

    var $function = this._logSetup($jp, insertBefore);
    if ($function === undefined) {
        return;
    }

    var $file = $function.ancestor('file');

	this._isCxx = $file.isCxx;
	
    var code = undefined;
    if ($file.isCxx) {
        code = this._log_cxx($file, $function);
    } else {
        code = this._log_c($file, $function);
    }

    if (code === undefined) {
        return;
    }

	this._insert($jp, insertBefore, code);
/*
    //call LoggerInsert($jp, code, insertBefore);
    if (this.insertBefore) {
        $jp.insertBefore(code);
    } else {
        $jp.insertAfter(code);
    }

    // Clear internal state
    this.currentElements = [];
	*/
    return this;
}


/**** PRIVATE METHODS ****/

/**
 * Checks the initial constrains before executing the actual log (ancestor function, minimum of elements to log, defines the value of insertBefore)
 * Should be called on the beggining of each implementation of log
 * 
 * @return undefined on failure and a $function instance if successful
 */
Logger.prototype._logSetup = function($jp, insertBefore) {
    // Validate join point
	if(!this._validateJp($jp, "function")) {
		return undefined;
	}

    if (this.currentElements.length === 0) {
        this._info("Nothing to log, call append() first");
        return undefined;
    }

    this.insertBefore = (insertBefore === undefined) ? false : insertBefore;
	// return $function
    return $jp.ancestor("function");
}

Logger.prototype._log_cxx = function($file, $function) {

	if(Clava.useSpecsLogger) {
		return this._log_cxx_specslogger($file, $function);
	} else {
		return this._log_cxx_stdcpp($file, $function);
	}

}

Logger.prototype._log_cxx_specslogger = function($file, $function) {
    var loggerName = this._setup_cxx_specslogger($file, $function);

	/*
    if (loggerName === undefined) {
        return;
    }
	*/

    // Create code from elements
    var code = loggerName + ".msg(" + this.currentElements.map(function(element) {
        return this._getPrintableContent(element);
    }, this).join(", ") + ");";

    return code;
}

/**
 * Sets up the code for the Logger in the file and function that is called
 */
Logger.prototype._setup_cxx_specslogger = function($file, $function) {

	// Warn user about dependency to SpecsLogger library
	//Clava.infoProjectDependency("SpecsLogger", "https://github.com/specs-feup/specs-c-libs");
	PrintOnce.message("Weaved code has dependency to project SpecsLogger, which can be found at https://github.com/specs-feup/specs-c-libs");
	
	var declaredName = this._declareName($function.declaration(true), function(){return IdGenerator.next("clava_logger_");});
	var loggerName = declaredName.name;
	
	if(declaredName.alreadyDeclared) {
		return loggerName;
	}
	
	
/*	
    // Check if setup was already called for this function
    var declaration = $function.declaration(true);
    var loggerName = this.functionMap[declaration];

    if (loggerName !== undefined) {
        return loggerName;
    } else {
        loggerName = IdGenerator.next("clava_logger_");
        this.functionMap[declaration] = loggerName;
    }
*/
    // Add include to Logger for Cpp only
    $file.addInclude("SpecsLogger.h", false);

    // Get correct logger
    var loggerDecl = undefined;

    // If filename use FileLogger 
    if (this.filename !== undefined) {
        loggerDecl = "FileLogger " + loggerName + "(\"" + this.filename + "\");";
    }
    // Otherwise, use ConsoleLogger
    else {
        loggerDecl = "ConsoleLogger " + loggerName + ";";
    }

    // Add declaration of correct logger
    $function.body.insertBegin(loggerDecl);

    return loggerName;
}

Logger.prototype._log_cxx_stdcpp = function($file, $function) {


	var streamName;
	if(this.filename === undefined) {
		streamName = this._setup_cxx_stdcpp_console($file, $function);
	} else {
		streamName = this._setup_cxx_stdcpp_file($file, $function);
	}
	
	 // Create code from elements.
    var code = streamName + " << " + this.currentElements.map(function(element) {
		if(element.type === this.Type.NORMAL) {
			return '"' + element.content + '"';
		}
        
		return element.content;
    }, this).join(" << ") + ";";

    return code;
	
}


Logger.prototype._setup_cxx_stdcpp_console = function($file, $function) {

    var streamName = "std::cout";

	// Add include
    $file.addInclude("iostream", true);
	
	return streamName;
}


Logger.prototype._setup_cxx_stdcpp_file = function($file, $function) {

	var declaredName = this._declareName($function.declaration(true), function(){return IdGenerator.next("log_file_");});
	var streamName = declaredName.name;
	
	if(declaredName.alreadyDeclared) {
		return streamName;
	}
	
	
	
	// Add include
    $file.addInclude("fstream", true);

	// Declare file stream
	//var code = "std::ofstream " + streamName + ";\n";

	// Open file
	//code = code + streamName + ".open(\"" + this.filename + "\", std::ios_base::app);";
	
    // Add code at beginning of the function
//    $function.body.insertBegin(code);

	// Declare file stream and open file
	$function.body.insertBegin(_clava_logger_filename_declaration_cpp(streamName, this.filename));
	
    return streamName;
}

Logger.prototype._log_c = function($file, $function) {

	if (this.filename === undefined) {
		return this._log_c_console($file, $function);
	} else {
		return this._log_c_file($file, $function);
	}
	/*
    if (!this._setup_c($file, $function)) {
        return;
    }

    return this._printfFormat("printf");
	*/
}

/**
 * Sets up the code for the Logger in the file that is called
 */
 /*
Logger.prototype._setup_c = function($file, $function) {

	if (this.filename === undefined) {
		return _setup_c_console($file, $function);
	} else {
		return _setup_c_file($file, $function);
	}

    // Add stdio.h if console, not implemented yet for file
    if (this.filename !== undefined) {
        this._warn('Not implemented for C files when a "filename" is defined');
        return false;
    }

    $file.addInclude("stdio.h", true);

    return true;
}
*/

Logger.prototype._log_c_console = function($file, $function) {
    // Setup
	$file.addInclude("stdio.h", true);
	
	return this._printfFormat("printf");
//    return true;
}

Logger.prototype._log_c_file = function($file, $function) {
	var fileVar = this._log_c_file_setup($file, $function);

	return this._printfFormat("fprintf", "(" + fileVar + ", \"");
}

Logger.prototype._log_c_file_setup = function($file, $function) {
	var declaredName = this._declareName($function.declaration(true), function(){return IdGenerator.next("log_file_");});
	var varname = declaredName.name;
	
	if(declaredName.alreadyDeclared) {
		return varname;
	}

    // Setup
	$file.addInclude("stdio.h", true);
	$file.addInclude("stdlib.h", true);

	// Declare and open file
	var code = _clava_logger_filename_declaration(varname, this.filename);
	
    // Add code at beginning of the function
    $function.body.insertBegin(code);

	// Close file at the end of the function
	$function.body.insertEnd("fclose(" + varname + ");");
	
	return varname;
}

codedef _clava_logger_filename_declaration(varname, filename) %{
FILE *[[varname]] = fopen("[[filename]]", "a+");
if ([[varname]] == NULL)
{
    printf("Error opening file [[filename]]\n");
    exit(1);
} 
}% end

codedef _clava_logger_filename_declaration_cpp(streamName, filename) %{
std::ofstream [[streamName]];
[[streamName]].open("[[filename]]", std::ios_base::app);
}% end