<div id='toc_container'><p class='toc_title'>import antarex.precision.CustomPrecision;</p><ul class='toc_list'><p class='toc_class'>Aspects:</p><li class='toc_class_element toc_top_element'><a href='#A'>CustomPrecisionFor</a></li><li class='toc_class_element toc_top_element'><a href='#B'>CustomPrecisionForExcept</a></li><li class='toc_class_element toc_top_element'><a href='#C'>CustomPrecisionGenParametersFor</a></li><li class='toc_class_element toc_top_element'><a href='#D'>CustomPrecision_Finalize</a></li><li class='toc_class_element toc_top_element'><a href='#E'>CustomPrecision_Initialize</a></li><li class='toc_class_element toc_top_element'><a href='#F'>ExtractDoubleFloatConstants</a></li><li class='toc_class_element toc_top_element'><a href='#G'>addDeclarations</a></li><li class='toc_class_element toc_top_element'><a href='#H'>extractFormat</a></li><li class='toc_class_element toc_top_element'><a href='#I'>extractStatementWithFormat</a></li><li class='toc_class_element toc_top_element'><a href='#J'>renameFuncNames</a></li><li class='toc_class_element toc_top_element'><a href='#K'>renameFunctions</a></li></ul></div><h2>Aspects</h2><h3 id='A'>CustomPrecisionFor</h3><p>It parametrizes the application for a type (vtype).<br>It calls CustomPrecisionForExcept(vtype, []), ie without no preserved types.</p><br><h4>Inputs</h4><div class='parameters'><span class='parameter'><strong>vtype</strong>: any</span><br></div><hr><h3 id='B'>CustomPrecisionForExcept</h3><p>It parametrizes the application by<br>- replacing the reference to a type (vtype) by a new symbol,<br>except the types declared in ArrayOfPreservedTypes<br>- replacing the formats used in the IO instructions by new symbols.<br>- replacing the references to math functions (sin, sinh, ...) by new symbols.<br>The parametrization creates some files in which the parameters are stored:<br>- INRIA_PRECISION_DEFS_[vtype].h that defines the parameters with the original values<br>for each new created symbols.<br>- INRIA_PRECISION_DEFS_XX_template.h in which the definition of the symbols must<br>be updated by the user, where XX denotes the new symbol assigned to to the customized type.<br><br>A type such that MYTYPE defined by<br>typedef double MYTYPE;<br>may be preserved by calling<br>CustomPrecisionForExcept('double', ['MYTYPE']). In this case the typedef is not modified.<br><br>Note:  genParametersFor aspect can be called for float/double types to have definitions of the symbols.</p><br><h4>Inputs</h4><div class='parameters'><span class='parameter'><strong>vtype</strong>: any</span><br><span class='parameter'><strong>ArrayOfPreservedTypes</strong>: any</span><br></div><hr><h3 id='C'>CustomPrecisionGenParametersFor</h3><p>Generate a include file INRIA_PRECISION_DEFS_[vtype].h that contains the<br>definitions of the type parametrization for vtype, restricted to float/double<br>(i.e. it is an instance of INRIA_PRECISION_DEFS_XX_template.h for vtype).</p><br><h4>Inputs</h4><div class='parameters'><span class='parameter'><strong>vtype</strong>: any</span><br></div><hr><h3 id='D'>CustomPrecision_Finalize</h3><p>Global Initialization of the component: it must be called once at the end of a type precision session.</p><br><hr><h3 id='E'>CustomPrecision_Initialize</h3><p>Global Initialization of the component: it must be called once at the beginning<br>of a type precision session.</p><br><hr><h3 id='F'>ExtractDoubleFloatConstants</h3><hr><h3 id='G'>addDeclarations</h3><p>Add to each file (source, headers except the added files) the declaration of the include that defines the<br>typed parameters.</p><br><hr><h3 id='H'>extractFormat</h3><p>It calls extractStatementWithFormat aspect for each IO of C language that references format<br>with the index of the format in the instruction.<br>int scanf(const char *format, ...);<br>int fscanf(FILE *stream, const char *format, ...);<br>int sscanf(const char *str, const char *format, ...);<br>int vscanf(const char *format, va_list ap);<br>int vsscanf(const char *str, const char *format, va_list ap);<br>int vfscanf(FILE *stream, const char *format, va_list ap);<br><br>At the end, the global associative table statementsWithFormatOriVersion constains elements such that<br>statementsWithFormatOriVersion[_INRIA_IO_FORMAT_XX] = FORMAT, where _INRIA_IO_FORMAT_XX is a new symbol<br>and FORMAT is a format that references float/double codification (%f, %lf,...)<br><br>Restiction to double/float types.</p><br><hr><h3 id='I'>extractStatementWithFormat</h3><p>Store in the global table statementsWithFormatOriVersion the formats used in IO instructions (C language).<br>Each string (S) that references float/double format is replaced by a new name (NAME) and<br>statementsWithFormatOriVersion[NAME] = S.<br>Restiction to double/float types.</p><br><h4>Inputs</h4><div class='parameters'><span class='parameter'><strong>fname</strong>: any</span><br><span class='parameter'><strong>numarg</strong>: any</span><br></div><hr><h3 id='J'>renameFuncNames</h3><p>Replace the calls to pname by nname, @return in referenced the value 'true' if<br>pname is referenced in the application, 'false' otherwise.</p><br><h4>Inputs</h4><div class='parameters'><span class='parameter'><strong>pname</strong>: any</span><br><span class='parameter'><strong>nname</strong>: any</span><br></div><h4>Outputs</h4><div class='parameters'><span class='parameter'><strong>referenced</strong>: any</span><br></div><hr><h3 id='K'>renameFunctions</h3><p>Extract the math functions if the source type is float or double.<br>The global mathLibReferenced array contains the referenced math functions.<br>Extract some predefined functions such that stod, stof,...<br>The global predefinedFuncsReferenced array contains these referenced functions.</p><br><hr>