<div id='toc_container'><p class='toc_title'>import antarex.split.splitLoopAspects;</p><ul class='toc_list'><p class='toc_class'>Aspects:</p><li class='toc_class_element toc_top_element'><a href='#A'>normalizeLoopsToBeSplitted</a></li><li class='toc_class_element toc_top_element'><a href='#B'>splitLoop_Declarations</a></li><li class='toc_class_element toc_top_element'><a href='#C'>splitLoop_ExtractCode</a></li><li class='toc_class_element toc_top_element'><a href='#D'>splitLoops</a></li><li class='toc_class_element toc_top_element'><a href='#E'>splitLoops_finalize</a></li><li class='toc_class_element toc_top_element'><a href='#F'>splitLoops_initialize</a></li></ul></div><h2>Aspects</h2><h3 id='A'>normalizeLoopsToBeSplitted</h3><p>It normalized the loops annotated with the pragma named SPLITLOOP<br><br>The normal form is<br>for (i=lbound, i &lt;= ubound, i++) { .... }<br><br>Currently, it does not transform anything. Not yet implemented.<br>to the normal form.</p><br><h4>Outputs</h4><div class='parameters'><span class='parameter'><strong>modified</strong>: any</span><br><span class='parameter'><strong>allNormalized</strong>: any</span><br><span class='parameter'><strong>found</strong>: any</span><br></div><hr><h3 id='B'>splitLoop_Declarations</h3><p>The interface (external references) of the loops to split is computed.<br>These symbols are managed as global variables of the application: new symbols are used for that.<br>The new symbols will be used in the extracted phasis of code to declared them as external symbols.</p><br><hr><h3 id='C'>splitLoop_ExtractCode</h3><p>Extract the code of the loops to be splitted.<br>For such a loop, it creates a new function(or method) in a new file<br>with lower and upper bounds as parameters.<br>The original code then is replaced by a set of calls, depending on the number of parts specified in<br>the pragma. The pragma is then removed from the code.</p><br><hr><h3 id='D'>splitLoops</h3><p>Split the loops annotated with the pragma named SPLITLOOP.<br>#pragma SPLITLOOP NBPARTS<br><br>where NBPARTS is the number of parts.<br><br>It calls the following aspects:<br>- normalizeLoopsToBeSplitted(): normalize of the loops to split.<br>- splitLoop_Declarations(): synthetize the interface of the loops.<br>- splitLoop_ExtractCode(): extract the code in new files.<br><br>and it also generates the algorithm required to select the best choice (function generateBestChoiceCode())<br><br>Example:<br>#pragma  SPLITLOOP 3<br>for (i=vmin, i &lt;= vmax, i++) { .... }</p><br><hr><h3 id='E'>splitLoops_finalize</h3><p>Finalize the components of the split compilation.</p><br><hr><h3 id='F'>splitLoops_initialize</h3><p>Initialize the components of the split compilation.</p><br><hr>