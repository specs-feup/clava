<div id='toc_container'><p class='toc_title'>import clava.hls.HLSAnalysis;</p><ul class='toc_list'><p class='toc_class'>Classes:</p><li class='toc_class_element toc_top_element'><a href='#A'>HLSAnalysis</a></li><ul class='toc_sublist'><div class='toc_sublist_title'>Constructor</div><li><em><a href='#B'>HLSAnalysis</a></em></li></ul><ul class='toc_sublist'><div class='toc_sublist_title'>Static Members</div><li><em><a href='#C'>applyArrayStreaming()</a></em></li><li><em><a href='#D'>applyFunctionInlining()</a></em></li><li><em><a href='#E'>applyGenericStrategies()</a></em></li><li><em><a href='#F'>applyLoadStoresStrategy()</a></em></li><li><em><a href='#G'>applyLoopStrategies()</a></em></li><li><em><a href='#H'>canBeInstrumented()</a></em></li><li><em><a href='#I'>getJavaInterface()</a></em></li></ul></ul></div><h1 id='A'>HLSAnalysis</h1><div class='function_block'><h3 id='B'>HLSAnalysis</h3><pre class='signature'><code class='language-js'><strong>HLSAnalysis</strong></code></pre><div class='function_content'></div><hr></div><h2>Static Members</h2><div class='function_block'><h3 id='C'>applyArrayStreaming</h3><pre class='signature'><code class='language-js'><strong>applyArrayStreaming</strong>(func)</code></pre><div class='function_content'><p>This strategy analyzes every input/output array of the function, and<br>tries to see if they can be implemented as a FIFO. To do this, the strategy<br>makes a series of checks to see whether the array can be implemented as such.<br>These checks are:<br>- Check if the array only has either loads or stores operations<br>- Check if the array is always accessed sequentially (limited by the information<br>available at compile time)<br>- Check whether each array position is accessed only once during the entire function<br>lifetime<br>If all these checks apply, the array is implemented as a FIFO using a Vivado HLS directive.</p><h4>Parameters</h4><div class='parameters'><span class='parameter'><strong>func</strong>: Function</span> - a JoinPoint of the function to analyze<br></div></div><hr></div><div class='function_block'><h3 id='D'>applyFunctionInlining</h3><pre class='signature'><code class='language-js'><strong>applyFunctionInlining</strong>(func, B)</code></pre><div class='function_content'><p>Applies the function inlining directive to every called function.<br>It works by calculating the cost of both the called function and the callee,<br>in which cost is defined as the total number of array loads on the total lifetime<br>of the function. This is then fed to the formula:<br><br>calleeCost &gt; (callFrequency * calledCost) / B<br><br>If this function is true, the function is inlined. Factor B is configurable, and allows<br>for this formula to be more restrictive/permissive, based on the user's needs. The<br>default value is 2.</p><h4>Parameters</h4><div class='parameters'><span class='parameter'><strong>func</strong>: Function</span> - a JoinPoint of the function to analyze<br><span class='parameter'><strong>B</strong>: number</span> - a positive real number to control the heuristic's aggressiveness<br></div></div><hr></div><div class='function_block'><h3 id='E'>applyGenericStrategies</h3><pre class='signature'><code class='language-js'><strong>applyGenericStrategies</strong>(func, options)</code></pre><div class='function_content'><p>Applies a set of Vivado HLS directives to a provided function using a set<br>of strategies to select and configure those directives. This function applies the<br>main optimization flow, which is comprised of the following strategies, by this order:<br>- Function Inlining<br>- Array Streaming<br>- Loop strategies (loop unrolling, pipelining and array partitioning)<br>For a description of how each strategy works, as well as for a standalone version of<br>each of these strategies, please consult the other methods of this class.</p><h4>Parameters</h4><div class='parameters'><span class='parameter'><strong>func</strong>: Function</span> - a JoinPoint of the function to analyze<br><span class='parameter'><strong>options</strong>: JSON</span> - an optional argument to specify the HLS options. The format is the following: {&quot;B&quot;: 2, &quot;N&quot;: 32, &quot;P&quot;: 64} If not specified, the compiler will use the values provided in the example above.<br></div></div><hr></div><div class='function_block'><h3 id='F'>applyLoadStoresStrategy</h3><pre class='signature'><code class='language-js'><strong>applyLoadStoresStrategy</strong>(func, N)</code></pre><div class='function_content'><p>Applies the load/stores strategy to simple loops. A simple loop is defined as<br>a function with only one loop with no nests, and in which every array is either only<br>loaded from or stored to in each iteration. This method can validate whether the provided<br>function is a simple loop or not. If it is one, then it applies three HLS directives in tandem:<br>it unrolls the loop by a factor N (called the load/stores factor), it partitions each array by<br>that same factor N using a cyclic strategy and finally it pipelines the loop. This strategy is<br>better than the other generic strategies for this type of function. Generally, larger values lead<br>to a better speedup, although there are exceptions. Therefore, it is recommended for users to<br>experiment with different values if results are unsatisfactory (the default value is 32).</p><h4>Parameters</h4><div class='parameters'><span class='parameter'><strong>func</strong>: Function</span> - a JoinPoint of the function to analyze<br><span class='parameter'><strong>N</strong>: number</span> - a positive integer value for the load/stores factor<br></div></div><hr></div><div class='function_block'><h3 id='G'>applyLoopStrategies</h3><pre class='signature'><code class='language-js'><strong>applyLoopStrategies</strong>(func, P)</code></pre><div class='function_content'><p>Analyzes every loop nest of a function and applies loop optimizations. These<br>optimizations are a combination of loop unrolling and loop pipelining. For the latter<br>to be efficient, array partitioning is also applied. This strategy works by always<br>unrolling the innermost loop of every nest, with a resource limitation directive to<br>prevent excessive resource usage. Then, if the number of iterations of the outermost<br>loop is less than 4, that loop is also unrolled, and so on. However, this is an edge case,<br>since this rarely happens; the outermost loop is, instead, pipelined. The array partitioning<br>is done in two ways: if an array is less than 4096 bytes, it is mapped into registers; otherwise,<br>it is partitioned into P partitions using a cyclic strategy.</p><h4>Parameters</h4><div class='parameters'><span class='parameter'><strong>func</strong>: Function</span> - a JoinPoint of the function to analyze<br><span class='parameter'><strong>P</strong>: number</span> - the number of partitions to use. 64 is the default.<br></div></div><hr></div><div class='function_block'><h3 id='H'>canBeInstrumented</h3><pre class='signature'><code class='language-js'><strong>canBeInstrumented</strong>(func)</code></pre><div class='function_content'><p>Checks whether a function can be instrumented. Only workds for old versions<br>of the trace2c tool.</p><h4>Parameters</h4><div class='parameters'><span class='parameter'><strong>func</strong>: Function</span> - a JoinPoint of the function to analyze<br></div><h4>Returns</h4><div class='parameters'><span class='parameter'>boolean</span> - whether the function can be or not instrumented<br></div></div><hr></div><div class='function_block'><h3 id='I'>getJavaInterface</h3><pre class='signature'><code class='language-js'><strong>getJavaInterface</strong>()</code></pre><div class='function_content'></div><hr></div>